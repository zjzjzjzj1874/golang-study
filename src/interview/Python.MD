
## Python

### 基础

#### Python为什么使用多线程并不能提高程序执行速度
经常听到小伙伴提到Python是单线程的，写代码的时候用多线程没有意义，今天来分享一下Python的单线程与多线程的理解。
* 首先说一下：Python说是单线程是错误的；写代码用多线程没意义，这句话是不准确的。
* GIL：Python的全局解释器锁。
  * GIL是CPython中的一把全局解释器锁(Global Interpreter Lock),在解释器解释执行Python代码时，要先得到这把锁，意味着任何时候只可能有一个线程在执行代码，其他线程想要获得CPU执行代码指令，
    必须先获得这把锁，如果锁被其他线程占用了，那么该线程只能等待，直到获得锁时才能执行代码。
  * GIL不是Python的特性，而是在实现Python解释器(CPython)时所引入的一个概念。好比C++是一套语言(语法)标准，但是可以用不同的编译器来编译成可执行的代码。
    有名的编译器例如GCC，MinGW(Windows平台)，Visual C++等。Python也一样，同样的代码可以通过CPython、PyPy、Psyco等不同的Python执行环境来执行。其中JPython就没有GIL。
    不过CPython是大部分环境下默认的Python执行环境，所以很多人不区分CPython和Python，把GIL归结为Python的语言缺陷。这里明确：**GIL不是Python特性，Python也可以不依赖GIL**。
  * GIL释放机制：当一个线程遇到I/O任务时，将释放GIL；计算密集型(CPU-Bound)现场执行100次解释器的计步(ticks，可调用sys.setcheckinterval设置)时也会释放GIL；多线程会额外带来锁、上下文切换的开销；
  * 设计初衷：多线程是为了冲分利用现代计算机多核处理器的优势；而1991年，Python诞生的时候，硬件配置还比较低，多线程的数据共享、同步和一致性问题处理很麻烦，Python之父直接搞了个全局线程锁，保证数据安全。所以90年代这种处理没啥问题。
  * GIL能去掉吗？可以的，只是1999年Greg Stein和Mark Hammond去掉后，执行效率慢了将近2倍，只是现在还没有合适的解释器来替换CPython。
* 实验1：就是将数字 "1亿" 递减，减到 0 程序就终止，这个任务如果我们使用单线程来执行，完成时间会是多少？使用多线程又会是多少？
  * 单线程：时间是 6.5 秒
  * 两个线程：以合作的方式执行是 6.8 秒
  * 原因: 因为GIL，同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上线文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。
* 实验2：一个应用有三个接口，接口A需要花费10s(CPU消耗，不包含网络通信等消耗时间)；接口B需要花费5s(CPU消耗，不包含网络通信等消耗时间)；接口C需要花费2s(CPU消耗，不包含网络通信等消耗时间)；
  假设三个用户同一时刻同时请求：甲请求A接口，乙请求B接口，丙请求C接口：
  * 单线程：甲10s收到结果，乙15s收到结果，丙17s收到结果；
  > 丙接口虽然很快，但是因为单线程，请求必须排队，所以要等待17s才能轮到他
  * 多线程：甲12s收到结果，乙7s收到结果，丙3s收到结果；
  > 三个方法交替轮番执行，数值是个大概数值
  * 结论：多线程使用程序交替轮番执行，不会对后边的程序产生阻塞(这才是Python应用多线程的根本目的)；多线程提升不了CPU的处理效率，只能提供调用CPU的方案。